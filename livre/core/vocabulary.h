// Generated by zerobufCxx.py

#pragma once
#include <zerobuf/ConstVector.h>
#include <zerobuf/NonMovingAllocator.h>
#include <zerobuf/Schema.h>
#include <zerobuf/Vector.h>
#include <zerobuf/Zerobuf.h>

namespace zeq
{
namespace vocabulary
{
enum EventDirection
{
    EventDirection_Subscriber,
    EventDirection_Publisher,
    EventDirection_Both,
};

template< class Alloc = zerobuf::NonMovingAllocator >
class VocabularyBase : public zerobuf::Zerobuf
{
public:
    typedef ::zerobuf::Vector< char* > RestNames;
    typedef ::zerobuf::ConstVector< char* > ConstRestNames;
    typename VocabularyBase< Alloc >::RestNames getRestNames();
    typename VocabularyBase< Alloc >::ConstRestNames getRestNames() const;
    void setRestNames( char* const * value, size_t size );
    std::vector< char* > getRestNamesVector() const;
    void setRestNames( const std::vector< char* >& value );
    std::string getRestNamesString() const;
    void setRestNames( const std::string& value );

    typedef ::zerobuf::Vector< uint64_t > EventHighs;
    typedef ::zerobuf::ConstVector< uint64_t > ConstEventHighs;
    typename VocabularyBase< Alloc >::EventHighs getEventHighs();
    typename VocabularyBase< Alloc >::ConstEventHighs getEventHighs() const;
    void setEventHighs( uint64_t const * value, size_t size );
    std::vector< uint64_t > getEventHighsVector() const;
    void setEventHighs( const std::vector< uint64_t >& value );
    std::string getEventHighsString() const;
    void setEventHighs( const std::string& value );

    typedef ::zerobuf::Vector< uint64_t > EventLows;
    typedef ::zerobuf::ConstVector< uint64_t > ConstEventLows;
    typename VocabularyBase< Alloc >::EventLows getEventLows();
    typename VocabularyBase< Alloc >::ConstEventLows getEventLows() const;
    void setEventLows( uint64_t const * value, size_t size );
    std::vector< uint64_t > getEventLowsVector() const;
    void setEventLows( const std::vector< uint64_t >& value );
    std::string getEventLowsString() const;
    void setEventLows( const std::string& value );

    typedef ::zerobuf::Vector< EventDirection > EventDirections;
    typedef ::zerobuf::ConstVector< EventDirection > ConstEventDirections;
    typename VocabularyBase< Alloc >::EventDirections getEventDirections();
    typename VocabularyBase< Alloc >::ConstEventDirections getEventDirections() const;
    void setEventDirections( EventDirection const * value, size_t size );
    std::vector< EventDirection > getEventDirectionsVector() const;
    void setEventDirections( const std::vector< EventDirection >& value );
    std::string getEventDirectionsString() const;
    void setEventDirections( const std::string& value );

    typedef ::zerobuf::Vector< char* > Schemas;
    typedef ::zerobuf::ConstVector< char* > ConstSchemas;
    typename VocabularyBase< Alloc >::Schemas getSchemas();
    typename VocabularyBase< Alloc >::ConstSchemas getSchemas() const;
    void setSchemas( char* const * value, size_t size );
    std::vector< char* > getSchemasVector() const;
    void setSchemas( const std::vector< char* >& value );
    std::string getSchemasString() const;
    void setSchemas( const std::string& value );

    VocabularyBase();
    explicit VocabularyBase( const ::zerobuf::Zerobuf& from );
    VocabularyBase( const VocabularyBase& from );
    virtual ~VocabularyBase() {}

    VocabularyBase& operator = ( const VocabularyBase& rhs )
        { ::zerobuf::Zerobuf::operator = ( rhs ); return *this; }

    static bool isEmptyZerobuf() { return false; }
    static bool isStaticZerobuf() { return false; }
    servus::uint128_t getZerobufType() const override
        { return servus::uint128_t( 0x7201efbaa3c1fc79ull, 0x7fee7d1c02e2a127ull ); }

    static ::zerobuf::Schema schema();
    ::zerobuf::Schema getSchema() const override { return schema(); }

private:
};

typedef VocabularyBase< ::zerobuf::NonMovingAllocator > Vocabulary;

}
}

#include "vocabulary.ipp"

